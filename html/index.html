<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta 
     name='viewport' 
     content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0' 
/>
    <style>
      html, body {
        width: 100%;
        height: 100%;
        margin: 0px;
        border: 0;
        overflow: hidden; /*  Disable scrollbars */
        display: block;  /* No floating content on sides */
      }

      button#shoot {
        position: absolute;
        bottom: 20px;
        width: 100px;
        height: 100px;
        border-radius: 50%;
        left: 20px;
        outline: none;
      }
      div.refresh{
        margin: auto;
      }
      h2 {text-align: center;}
      p {text-align: center;}

      div.refresh{
        text-align: center;
        position: fixed;
        left: 0;
        right: 0;
        top: 40%;
        margin-top: 25%;
      }

      .loader {
        border: 6px solid #f3f3f3;
        border-radius: 50%;
        border-top: 6px solid #3498db;
        width: 30px;
        height: 30px;
        -webkit-animation: spin 2s linear infinite;
        animation: spin 2s linear infinite;
        align-content: center;
        position: fixed;
        top: 45%;
        left: 0;
        right: 0;
        display: none;
        margin: auto;
      }

      /* Safari */
      @-webkit-keyframes spin {
        0% { -webkit-transform: rotate(0deg); }
        100% { -webkit-transform: rotate(360deg); }
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }   

      </style>
  </head>

  <body>
    <div id="game">
      <canvas id="canvas" style='position:absolute; left:0px; top:0px; width: 100%'></canvas>

      <button id="shoot">SHOOT</button> 

    </div>

    <div class="loader"></div>

    <div id="ref"><div id="refresh"></div>

      <h2>Game Over</h2>
      <p id="score">Your Score is 0</p>

    </div>

<script>


  var currentScore = 0;
  var previousScore = 0;


  function GDefCallback(callbackId, jsonPayload) {
    document.getElementById("refresh").style.display = "none";
    document.getElementById("score").style.display = "block";
  }

  // Returns an object containing resources that will be used later for drawing
  function resources() {
    let res = {
      player: document.createElement('canvas'),
      enemy: document.createElement('canvas'),
      bullet: document.createElement('canvas'),
      particle: document.createElement('canvas'),
      shoot: document.createElement('canvas')
    }

    //Shoot Button
    res.particle.width = 100;
    res.particle.height = 100;
    let sCtx = res.particle.getContext('2d')
    sCtx.fillStyle = "white";
    sCtx.beginPath();
    sCtx.arc(10, 10, 10, 0, 2 * Math.PI);
    sCtx.fill();

    // Particle
    res.particle.width = 20;
    res.particle.height = 20;
    let pCtx = res.particle.getContext('2d');
    pCtx.fillStyle = "darkviolet";
    pCtx.beginPath();
    pCtx.arc(10, 10, 10, 0, 2 * Math.PI);
    pCtx.fill();

    // Bullet
    res.bullet.width = 6;
    res.bullet.height = 6;
    let bCtx = res.bullet.getContext('2d');
    bCtx.fillStyle = "blue";
    bCtx.beginPath();
    bCtx.arc(3, 3, 3, 0, 2 * Math.PI);
    bCtx.fill();

    // Enemy
    res.enemy.width = 20;
    res.enemy.height = 20;
    let eCtx = res.enemy.getContext('2d');
    eCtx.fillStyle = "yellow";
    eCtx.beginPath();
    eCtx.arc(10, 10, 10, 0, 2 * Math.PI);
    eCtx.fill();

    // Player
    res.player.width = 20;
    res.player.height = 16;
    let plCtx = res.player.getContext('2d');
    plCtx.fillStyle = "red";
    plCtx.beginPath();
    plCtx.lineTo(20, 8);
    plCtx.lineTo(0, 16);
    plCtx.lineTo(0, 0);
    plCtx.fill();

    return res;
  }

  // We create this here because it will be used from within `imports`
  let canvas = document.getElementById('canvas');

  // Returns an object containing functions that will be linked to our wasm model
  // This means that they can be called from Rust
  function imports() {
    const res = resources();
    var ctx = canvas.getContext("2d");

    function clear_screen() {
      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function draw_shoot(x, y, angle) {
      ctx.translate(x, y);
      ctx.rotate(angle);
      ctx.translate(0, -8);
      ctx.drawImage(res.player, 0, 0);
      ctx.setTransform(1, 0, 0, 1, 0, 0);

      ctx.fillStyle = "black";
      //ctx.fillRect(x - 17, y - 12, 4, 4);
    }

    function draw_player(x, y, angle) {
      ctx.translate(x, y);
      ctx.rotate(angle);
      ctx.translate(0, -8);
      ctx.drawImage(res.player, 0, 0);
      ctx.setTransform(1, 0, 0, 1, 0, 0);

      ctx.fillStyle = "black";
      //ctx.fillRect(x - 17, y - 12, 4, 4);
    }

    function draw_enemy(x, y) {
      ctx.drawImage(res.enemy, x - 10, y - 10);
    }

    function draw_bullet(x, y) {
      ctx.drawImage(res.bullet, x - 3, y - 3);
    }

    function draw_particle(x, y, radius) {
      ctx.drawImage(res.particle, x - radius, y - radius, 2 * radius, 2 * radius);
    }

    function draw_score(x) {
      ctx.fillStyle = "orange";
      ctx.textBaseline = "top";
      ctx.font = "20px sans-serif";
      ctx.fillText('Score: ' + x, 10, 10)
      
      previousScore = currentScore;
      currentScore = x;
      console.log(`${x}  ${previousScore}`)

      if(previousScore > x ){
        console.log('Game Over');
    document.getElementById("game").style.display = "none";
    document.getElementById("canvas").style.display = "none";
    document.getElementById("shoot").style.display = "none";

    document.getElementById("refresh").style.display = "block";

    document.getElementById("score").style.display = "none";
    document.getElementById("score").innerHTML = `Your Score is ${previousScore}`;
  
    new BroadcastChannel("GDef").postMessage(
      {
      "callbackId":"100",
      "operation":"updateScore",
      "data": {
        "updateType":"increment",
        "scoreToUpdate": previousScore,
        "userId": "userid for which the score is updated"
      }}
    )
      }

    }


    // The real loading and running of our wasm starts here
    let imports = { clear_screen, draw_player, draw_enemy, draw_bullet, draw_particle, draw_score };
    imports.Math_atan = Math.atan;
    imports.sin = Math.sin;
    imports.cos = Math.cos;
    return imports;
  }

  // Fetch and instantiate our wasm module
  fetch("program.wasm").then(response =>
    response.arrayBuffer()
  ).then(bytes =>
    WebAssembly.instantiate(bytes, { env: imports() })
  ).then(results => {
    let module = {};
    let mod = results.instance;
    module.update = mod.exports.update;
    module.toggle_shoot = mod.exports.toggle_shoot;
    module.toggle_boost = mod.exports.toggle_boost;
    module.toggle_turn_left = mod.exports.toggle_turn_left;
    module.toggle_turn_right = mod.exports.toggle_turn_right;
    module.resize = mod.exports.resize;
    module.draw = mod.exports.draw;

    // Input processing
    function processKey(key, b) {
      switch (key) {
        case "ArrowLeft":
          module.toggle_turn_left(b);
          break;
        case "ArrowRight":
          module.toggle_turn_right(b);
          break;
        case "ArrowUp":
          module.toggle_boost(b);
          break;
        case " ":
          module.toggle_shoot(b);
          break;
      }
    }
    document.addEventListener('keydown', e => processKey(e.key, true));
    document.addEventListener('keyup', e => processKey(e.key, false));

    // Resizing
    function resize() {
      // We make the canvas somewhat smaller to get some zooming
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      module.resize(canvas.width, canvas.height);
    }
    // window.addEventListener('resize', () => {
    //   resize();
    // });

    
    document.addEventListener('touchstart', handleTouchStart, false);        
    document.addEventListener('touchmove', handleTouchMove, false);

    document.getElementById('shoot').addEventListener('click', function(){
      module.toggle_shoot(true);
      setTimeout(function (){
            module.toggle_shoot(false);
      }, 200);
    })

    var xDown = null;                                                        
    var yDown = null;

    function getTouches(evt) {
      return evt.touches ||             // browser API
            evt.originalEvent.touches; // jQuery
    }                                                     

    function handleTouchStart(evt) {
      const firstTouch = getTouches(evt)[0];                                      
      xDown = firstTouch.clientX;                                      
      yDown = firstTouch.clientY;                                      
    };                                                

    function handleTouchMove(evt) {
  if ( ! xDown || ! yDown ) {
      return;
  }

  var xUp = evt.touches[0].clientX;                                    
  var yUp = evt.touches[0].clientY;

  var xDiff = xDown - xUp;
  var yDiff = yDown - yUp;

  if ( Math.abs( xDiff ) > Math.abs( yDiff ) ) {/*most significant*/
      if ( xDiff > 0 ) {
          /* left swipe */ 
          module.toggle_turn_left(true);
          setTimeout(function (){
            module.toggle_turn_left(false);
          }, 200)
          
      } else {
          /* right swipe */
          module.toggle_turn_right(true);
          setTimeout(function (){
            module.toggle_turn_right(false);
          }, 200)
      }                       
  } else {
      if ( yDiff > 0 ) {
          /* up swipe */ 
          module.toggle_boost(true);
          setTimeout(function (){
            module.toggle_boost(false);
          }, 200)
          // 
      } else { 
          /* down swipe */
          
      }                                                                 
  }
  /* reset values */
  xDown = null;
  yDown = null;                                             
};
    

    // Game loop
    let start = null;
    let prevTimestamp = null;
    let drawAndUpdate = (timestamp) => {
      // Initialization
      if (!prevTimestamp) {
        start = timestamp;
        prevTimestamp = timestamp;
        requestAnimationFrame(drawAndUpdate);
        return;
      }

      // Update and draw
      let progress = (timestamp - prevTimestamp) / 1000;
      module.update(progress);
      module.draw();

      // Some bookkeeping
      prevTimestamp = timestamp;
      requestAnimationFrame(drawAndUpdate);
    };

    resize();
    drawAndUpdate();
  });
  </script>
  </body>
</html>
